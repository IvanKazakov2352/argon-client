//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a code generation tool.
//     Changes to this file may cause incorrect behavior and will be lost
//     if the code is regenerated.
//
//     Generator: IonPath Codegen
// </auto-generated>
//------------------------------------------------------------------------------
import { 
  CborReader, 
  CborWriter, 
  
  DateOnly, 
  DateTimeOffset, 
  Duration, 
  TimeOnly, 
  Guid, 
  
  IonFormatterStorage,

  IonArray, 
  IonMaybe,

  IIonService,
  IIonUnion,
  
  ServiceExecutor,
  IonClientContext,
  IonRequest,
  IonWsClient,
  IonInterceptor
} from "@argon-chat/ion.webcore";

type guid = Guid;
type timeonly = TimeOnly;
type duration = Duration;
type datetime = DateTimeOffset;
type dateonly = DateOnly;

declare type bool = boolean;

declare type i1 = number;
declare type i2 = number;
declare type i4 = number;
declare type i8 = bigint;
declare type i16 = bigint;


declare type u1 = number;
declare type u2 = number;
declare type u4 = number;
declare type u8 = bigint;
declare type u16 = bigint;


declare type f2 = number;
declare type f4 = number;
declare type f8 = number;

export interface ChannelEntitlementOverwrite {
  channelId: guid;
  archetypeId: IonMaybe<guid>;
  serverMemberId: IonMaybe<guid>;
  allow: ArgonEntitlement;
  deny: ArgonEntitlement;
  creatorId: guid;
  id: guid;
};


export interface Archetype {
  id: guid;
  spaceId: guid;
  name: string;
  description: string;
  isMentionable: bool;
  colour: i4;
  isHidden: bool;
  isLocked: bool;
  isGroup: bool;
  isDefault: bool;
  iconFileId: IonMaybe<string>;
  entitlement: string;
};


export interface CreateChannelRequest {
  spaceId: guid;
  name: string;
  kind: ChannelType;
  desc: string;
};


export interface RealtimeChannel {
  channel: ArgonChannel;
  users: IonArray<RealtimeChannelUser>;
};


export interface ArgonChannel {
  type: ChannelType;
  spaceId: guid;
  channelId: guid;
  name: string;
  description: IonMaybe<string>;
  categoryId: guid;
};


export interface ArgonMessage {
  messageId: u8;
  replyId: IonMaybe<u8>;
  channelId: guid;
  spaceId: guid;
  text: string;
  entities: IonArray<IMessageEntity>;
  timeSent: datetime;
  sender: guid;
};


export interface RealtimeChannelUser {
  userId: guid;
  state: ChannelMemberState;
};


export interface UserActivityPresence {
  kind: ActivityPresenceKind;
  startTimestampSeconds: u8;
  titleName: string;
};


export enum ChannelType
{
  Text = 0,
  Voice = 1,
  Announcement = 2,
}


export enum JoinToChannelError
{
  NONE = 0,
  CHANNEL_IS_NOT_VOICE = 1,
}


export enum EntityType
{
  Hashtag = 0,
  Mention = 1,
  Email = 2,
  Url = 3,
  Monospace = 4,
  Quote = 5,
  Spoiler = 6,
  Strikethrough = 7,
  Bold = 8,
  Italic = 9,
  Underline = 10,
  Fraction = 11,
  Ordinal = 12,
  Capitalized = 13,
}


export enum ActivityPresenceKind
{
  GAME = 0,
  SOFTWARE = 1,
  STREAMING = 2,
  LISTEN = 3,
}


export enum ChannelMemberState
{
  NONE = 0,
  MUTED = 2,
  MUTED_BY_SERVER = 4,
  MUTED_HEADPHONES = 8,
  MUTED_HEADPHONES_BY_SERVER = 16,
  STREAMING = 32,
}


export interface ArgonSpace {
  spaceId: guid;
  name: string;
  description: string;
  avatarFieldId: IonMaybe<string>;
  topBannerFileId: IonMaybe<string>;
  channels: IonArray<ArgonChannel>;
  members: IonArray<SpaceMember>;
  archetypes: IonArray<Archetype>;
};


export interface ArchetypeGroup {
  archetype: Archetype;
  members: IonArray<guid>;
};


export interface SpaceMemberArchetype {
  serverMemberId: guid;
  archetypeId: guid;
};


export interface SpaceMember {
  userId: guid;
  spaceId: guid;
  joinedAt: datetime;
  memberId: guid;
  user: ArgonUser;
  archetypes: IonArray<SpaceMemberArchetype>;
};


export interface RealtimeServerMember {
  member: SpaceMember;
  status: UserStatus;
  presence: IonMaybe<UserActivityPresence>;
};


export interface InviteCodeEntity {
  code: InviteCode;
  spaceId: guid;
  issuerId: guid;
  expireTime: datetime;
  used: u8;
};


export interface InviteCode {
  inviteCode: string;
};


export interface ArgonUser {
  userId: guid;
  username: string;
  displayName: string;
  avatarFileId: IonMaybe<string>;
};


export interface ArgonUserProfile {
  userId: guid;
  customStatus: IonMaybe<string>;
  customStatusIconId: IonMaybe<string>;
  bannerFileID: IonMaybe<string>;
  dateOfBirth: IonMaybe<dateonly>;
  bio: IonMaybe<string>;
  isPremium: bool;
  badges: IonArray<string>;
  archetypes: IonArray<SpaceMemberArchetype>;
};


export enum UserStatus
{
  Offline = 0,
  Online = 1,
  Away = 2,
  InGame = 3,
  Listen = 4,
  TouchGrass = 5,
  DoNotDisturb = 6,
}


export enum ArgonEntitlement
{
  None = 0,
  ViewChannel = 1,
  ReadHistory = 2,
  JoinToVoice = 4,
  SendMessages = 32,
  SendVoice = 64,
  AttachFiles = 128,
  AddReactions = 256,
  AnyMentions = 512,
  MentionEveryone = 1024,
  ExternalEmoji = 2048,
  ExternalStickers = 4096,
  UseCommands = 8192,
  PostEmbeddedLinks = 16384,
  Connect = 1048576,
  Speak = 2097152,
  Video = 4194304,
  Stream = 8388608,
  UseASIO = 1073741824,
  AdditionalStreams = 2147483648,
  DisconnectMember = 1099511627776,
  MoveMember = 2199023255552,
  BanMember = 4398046511104,
  MuteMember = 8796093022208,
  KickMember = 17592186044416,
  ManageChannels = 1125899906842624,
  ManageArchetype = 2251799813685248,
  ManageBots = 4503599627370496,
  ManageEvents = 9007199254740992,
  ManageBehaviour = 18014398509481984,
  ManageServer = 36028797018963968,
  Administrator = 9223372036854775808,
}


export interface FeatureFlag {
  key: string;
  enabled: bool;
  variant: IonMaybe<string>;
  parameters: IonArray<FeatureFlagParameter>;
};


export interface FeatureFlagParameter {
  key: string;
  value: string;
};


export interface CreateServerRequest {
  name: string;
  description: string;
  avatarFieldId: string;
};


export interface UserCredentialsInput {
  email: string;
  username: IonMaybe<string>;
  password: string;
  otpCode: IonMaybe<string>;
  captchaToken: IonMaybe<string>;
};


export interface NewUserCredentialsInput {
  email: string;
  username: string;
  password: string;
  displayName: string;
  argreeTos: bool;
  argreeOptionalEmails: bool;
  captchaToken: IonMaybe<string>;
};


export enum AcceptInviteError
{
  NONE = 0,
  NOT_FOUND = 1,
  EXPIRED = 2,
  YOU_ARE_BANNED = 3,
}


export enum AuthorizationError
{
  NONE = 0,
  BAD_CREDENTIALS = 1,
  REQUIRED_OTP = 2,
  BAD_OTP = 3,
}


export enum RegistrationError
{
  USERNAME_ALREADY_TAKEN = 0,
  USERNAME_RESERVED = 1,
  EMAIL_ALREADY_REGISTERED = 2,
  REGION_BANNED = 3,
  EMAIL_BANNED = 4,
  SSO_EMAILS_NOT_ALLOWED = 5,
  INTERNAL_ERROR = 6,
  VALIDATION_FAILED = 7,
}



export abstract class IMessageEntity implements IIonUnion<IMessageEntity>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
    abstract type: EntityType;
  abstract offset: i4;
  abstract length: i4;
  abstract version: i4;

  
  
  public isMessageEntityMention(): this is MessageEntityMention {
    return this.UnionKey === "MessageEntityMention";
  }
  public isMessageEntityEmail(): this is MessageEntityEmail {
    return this.UnionKey === "MessageEntityEmail";
  }
  public isMessageEntityHashTag(): this is MessageEntityHashTag {
    return this.UnionKey === "MessageEntityHashTag";
  }
  public isMessageEntityQuote(): this is MessageEntityQuote {
    return this.UnionKey === "MessageEntityQuote";
  }
  public isMessageEntityUnderline(): this is MessageEntityUnderline {
    return this.UnionKey === "MessageEntityUnderline";
  }
  public isMessageEntityUrl(): this is MessageEntityUrl {
    return this.UnionKey === "MessageEntityUrl";
  }

}


export class MessageEntityMention extends IMessageEntity
{
  constructor(public type: EntityType, public offset: i4, public length: i4, public version: i4, public userId: guid) { super(); }

  UnionKey: string = "MessageEntityMention";
  UnionIndex: number = 0;
}

export class MessageEntityEmail extends IMessageEntity
{
  constructor(public type: EntityType, public offset: i4, public length: i4, public version: i4, public email: string) { super(); }

  UnionKey: string = "MessageEntityEmail";
  UnionIndex: number = 1;
}

export class MessageEntityHashTag extends IMessageEntity
{
  constructor(public type: EntityType, public offset: i4, public length: i4, public version: i4, public hashtag: string) { super(); }

  UnionKey: string = "MessageEntityHashTag";
  UnionIndex: number = 2;
}

export class MessageEntityQuote extends IMessageEntity
{
  constructor(public type: EntityType, public offset: i4, public length: i4, public version: i4, public quotedUserId: guid) { super(); }

  UnionKey: string = "MessageEntityQuote";
  UnionIndex: number = 3;
}

export class MessageEntityUnderline extends IMessageEntity
{
  constructor(public type: EntityType, public offset: i4, public length: i4, public version: i4, public colour: i4) { super(); }

  UnionKey: string = "MessageEntityUnderline";
  UnionIndex: number = 4;
}

export class MessageEntityUrl extends IMessageEntity
{
  constructor(public type: EntityType, public offset: i4, public length: i4, public version: i4, public domain: string, public path: string) { super(); }

  UnionKey: string = "MessageEntityUrl";
  UnionIndex: number = 5;
}



IonFormatterStorage.register("IMessageEntity", {
  read(reader: CborReader): IMessageEntity {
    reader.readStartArray();
    let value: IMessageEntity = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<MessageEntityMention>("MessageEntityMention").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<MessageEntityEmail>("MessageEntityEmail").read(reader);
    else if (unionIndex == 2)
      value = IonFormatterStorage.get<MessageEntityHashTag>("MessageEntityHashTag").read(reader);
    else if (unionIndex == 3)
      value = IonFormatterStorage.get<MessageEntityQuote>("MessageEntityQuote").read(reader);
    else if (unionIndex == 4)
      value = IonFormatterStorage.get<MessageEntityUnderline>("MessageEntityUnderline").read(reader);
    else if (unionIndex == 5)
      value = IonFormatterStorage.get<MessageEntityUrl>("MessageEntityUrl").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IMessageEntity): void {
    writer.writeStartArray(null);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0)
      IonFormatterStorage.get<MessageEntityMention>("MessageEntityMention").write(writer, value as MessageEntityMention);
    else if (value.UnionIndex == 1)
      IonFormatterStorage.get<MessageEntityEmail>("MessageEntityEmail").write(writer, value as MessageEntityEmail);
    else if (value.UnionIndex == 2)
      IonFormatterStorage.get<MessageEntityHashTag>("MessageEntityHashTag").write(writer, value as MessageEntityHashTag);
    else if (value.UnionIndex == 3)
      IonFormatterStorage.get<MessageEntityQuote>("MessageEntityQuote").write(writer, value as MessageEntityQuote);
    else if (value.UnionIndex == 4)
      IonFormatterStorage.get<MessageEntityUnderline>("MessageEntityUnderline").write(writer, value as MessageEntityUnderline);
    else if (value.UnionIndex == 5)
      IonFormatterStorage.get<MessageEntityUrl>("MessageEntityUrl").write(writer, value as MessageEntityUrl);
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("MessageEntityMention", {
  read(reader: CborReader): MessageEntityMention {
    reader.readStartArray();
    const type = IonFormatterStorage.get<EntityType>('EntityType').read(reader);
    const offset = IonFormatterStorage.get<i4>('i4').read(reader);
    const length = IonFormatterStorage.get<i4>('i4').read(reader);
    const version = IonFormatterStorage.get<i4>('i4').read(reader);
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArray();
    return new MessageEntityMention(type, offset, length, version, userId);
  },
  write(writer: CborWriter, value: MessageEntityMention): void {
    writer.writeStartArray(null);
    IonFormatterStorage.get<EntityType>('EntityType').write(writer, value.type);
    IonFormatterStorage.get<i4>('i4').write(writer, value.offset);
    IonFormatterStorage.get<i4>('i4').write(writer, value.length);
    IonFormatterStorage.get<i4>('i4').write(writer, value.version);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("MessageEntityEmail", {
  read(reader: CborReader): MessageEntityEmail {
    reader.readStartArray();
    const type = IonFormatterStorage.get<EntityType>('EntityType').read(reader);
    const offset = IonFormatterStorage.get<i4>('i4').read(reader);
    const length = IonFormatterStorage.get<i4>('i4').read(reader);
    const version = IonFormatterStorage.get<i4>('i4').read(reader);
    const email = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArray();
    return new MessageEntityEmail(type, offset, length, version, email);
  },
  write(writer: CborWriter, value: MessageEntityEmail): void {
    writer.writeStartArray(null);
    IonFormatterStorage.get<EntityType>('EntityType').write(writer, value.type);
    IonFormatterStorage.get<i4>('i4').write(writer, value.offset);
    IonFormatterStorage.get<i4>('i4').write(writer, value.length);
    IonFormatterStorage.get<i4>('i4').write(writer, value.version);
    IonFormatterStorage.get<string>('string').write(writer, value.email);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("MessageEntityHashTag", {
  read(reader: CborReader): MessageEntityHashTag {
    reader.readStartArray();
    const type = IonFormatterStorage.get<EntityType>('EntityType').read(reader);
    const offset = IonFormatterStorage.get<i4>('i4').read(reader);
    const length = IonFormatterStorage.get<i4>('i4').read(reader);
    const version = IonFormatterStorage.get<i4>('i4').read(reader);
    const hashtag = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArray();
    return new MessageEntityHashTag(type, offset, length, version, hashtag);
  },
  write(writer: CborWriter, value: MessageEntityHashTag): void {
    writer.writeStartArray(null);
    IonFormatterStorage.get<EntityType>('EntityType').write(writer, value.type);
    IonFormatterStorage.get<i4>('i4').write(writer, value.offset);
    IonFormatterStorage.get<i4>('i4').write(writer, value.length);
    IonFormatterStorage.get<i4>('i4').write(writer, value.version);
    IonFormatterStorage.get<string>('string').write(writer, value.hashtag);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("MessageEntityQuote", {
  read(reader: CborReader): MessageEntityQuote {
    reader.readStartArray();
    const type = IonFormatterStorage.get<EntityType>('EntityType').read(reader);
    const offset = IonFormatterStorage.get<i4>('i4').read(reader);
    const length = IonFormatterStorage.get<i4>('i4').read(reader);
    const version = IonFormatterStorage.get<i4>('i4').read(reader);
    const quotedUserId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArray();
    return new MessageEntityQuote(type, offset, length, version, quotedUserId);
  },
  write(writer: CborWriter, value: MessageEntityQuote): void {
    writer.writeStartArray(null);
    IonFormatterStorage.get<EntityType>('EntityType').write(writer, value.type);
    IonFormatterStorage.get<i4>('i4').write(writer, value.offset);
    IonFormatterStorage.get<i4>('i4').write(writer, value.length);
    IonFormatterStorage.get<i4>('i4').write(writer, value.version);
    IonFormatterStorage.get<guid>('guid').write(writer, value.quotedUserId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("MessageEntityUnderline", {
  read(reader: CborReader): MessageEntityUnderline {
    reader.readStartArray();
    const type = IonFormatterStorage.get<EntityType>('EntityType').read(reader);
    const offset = IonFormatterStorage.get<i4>('i4').read(reader);
    const length = IonFormatterStorage.get<i4>('i4').read(reader);
    const version = IonFormatterStorage.get<i4>('i4').read(reader);
    const colour = IonFormatterStorage.get<i4>('i4').read(reader);
    reader.readEndArray();
    return new MessageEntityUnderline(type, offset, length, version, colour);
  },
  write(writer: CborWriter, value: MessageEntityUnderline): void {
    writer.writeStartArray(null);
    IonFormatterStorage.get<EntityType>('EntityType').write(writer, value.type);
    IonFormatterStorage.get<i4>('i4').write(writer, value.offset);
    IonFormatterStorage.get<i4>('i4').write(writer, value.length);
    IonFormatterStorage.get<i4>('i4').write(writer, value.version);
    IonFormatterStorage.get<i4>('i4').write(writer, value.colour);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("MessageEntityUrl", {
  read(reader: CborReader): MessageEntityUrl {
    reader.readStartArray();
    const type = IonFormatterStorage.get<EntityType>('EntityType').read(reader);
    const offset = IonFormatterStorage.get<i4>('i4').read(reader);
    const length = IonFormatterStorage.get<i4>('i4').read(reader);
    const version = IonFormatterStorage.get<i4>('i4').read(reader);
    const domain = IonFormatterStorage.get<string>('string').read(reader);
    const path = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArray();
    return new MessageEntityUrl(type, offset, length, version, domain, path);
  },
  write(writer: CborWriter, value: MessageEntityUrl): void {
    writer.writeStartArray(null);
    IonFormatterStorage.get<EntityType>('EntityType').write(writer, value.type);
    IonFormatterStorage.get<i4>('i4').write(writer, value.offset);
    IonFormatterStorage.get<i4>('i4').write(writer, value.length);
    IonFormatterStorage.get<i4>('i4').write(writer, value.version);
    IonFormatterStorage.get<string>('string').write(writer, value.domain);
    IonFormatterStorage.get<string>('string').write(writer, value.path);
    writer.writeEndArray();
  }
});



export abstract class IJoinToVoiceResult implements IIonUnion<IJoinToVoiceResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessJoinVoice(): this is SuccessJoinVoice {
    return this.UnionKey === "SuccessJoinVoice";
  }
  public isFailedJoinVoice(): this is FailedJoinVoice {
    return this.UnionKey === "FailedJoinVoice";
  }

}


export class SuccessJoinVoice extends IJoinToVoiceResult
{
  constructor(public token: string) { super(); }

  UnionKey: string = "SuccessJoinVoice";
  UnionIndex: number = 0;
}

export class FailedJoinVoice extends IJoinToVoiceResult
{
  constructor(public error: JoinToChannelError) { super(); }

  UnionKey: string = "FailedJoinVoice";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("IJoinToVoiceResult", {
  read(reader: CborReader): IJoinToVoiceResult {
    reader.readStartArray();
    let value: IJoinToVoiceResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessJoinVoice>("SuccessJoinVoice").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<FailedJoinVoice>("FailedJoinVoice").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IJoinToVoiceResult): void {
    writer.writeStartArray(null);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0)
      IonFormatterStorage.get<SuccessJoinVoice>("SuccessJoinVoice").write(writer, value as SuccessJoinVoice);
    else if (value.UnionIndex == 1)
      IonFormatterStorage.get<FailedJoinVoice>("FailedJoinVoice").write(writer, value as FailedJoinVoice);
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessJoinVoice", {
  read(reader: CborReader): SuccessJoinVoice {
    reader.readStartArray();
    const token = IonFormatterStorage.get<string>('string').read(reader);
    reader.readEndArray();
    return new SuccessJoinVoice(token);
  },
  write(writer: CborWriter, value: SuccessJoinVoice): void {
    writer.writeStartArray(null);
    IonFormatterStorage.get<string>('string').write(writer, value.token);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FailedJoinVoice", {
  read(reader: CborReader): FailedJoinVoice {
    reader.readStartArray();
    const error = IonFormatterStorage.get<JoinToChannelError>('JoinToChannelError').read(reader);
    reader.readEndArray();
    return new FailedJoinVoice(error);
  },
  write(writer: CborWriter, value: FailedJoinVoice): void {
    writer.writeStartArray(null);
    IonFormatterStorage.get<JoinToChannelError>('JoinToChannelError').write(writer, value.error);
    writer.writeEndArray();
  }
});



export abstract class IArgonEvent implements IIonUnion<IArgonEvent>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
    abstract spaceId: guid;

  
  
  public isArchetypeChanged(): this is ArchetypeChanged {
    return this.UnionKey === "ArchetypeChanged";
  }
  public isArchetypeCreated(): this is ArchetypeCreated {
    return this.UnionKey === "ArchetypeCreated";
  }
  public isChannelCreated(): this is ChannelCreated {
    return this.UnionKey === "ChannelCreated";
  }
  public isChannelModified(): this is ChannelModified {
    return this.UnionKey === "ChannelModified";
  }
  public isChannelRemoved(): this is ChannelRemoved {
    return this.UnionKey === "ChannelRemoved";
  }
  public isIAmTypingEvent(): this is IAmTypingEvent {
    return this.UnionKey === "IAmTypingEvent";
  }
  public isIAmStopTypingEvent(): this is IAmStopTypingEvent {
    return this.UnionKey === "IAmStopTypingEvent";
  }
  public isUserTypingEvent(): this is UserTypingEvent {
    return this.UnionKey === "UserTypingEvent";
  }
  public isUserStopTypingEvent(): this is UserStopTypingEvent {
    return this.UnionKey === "UserStopTypingEvent";
  }
  public isJoinedToChannelUser(): this is JoinedToChannelUser {
    return this.UnionKey === "JoinedToChannelUser";
  }
  public isJoinToServerUser(): this is JoinToServerUser {
    return this.UnionKey === "JoinToServerUser";
  }
  public isLeavedFromChannelUser(): this is LeavedFromChannelUser {
    return this.UnionKey === "LeavedFromChannelUser";
  }
  public isUserUpdated(): this is UserUpdated {
    return this.UnionKey === "UserUpdated";
  }
  public isOnUserPresenceActivityChanged(): this is OnUserPresenceActivityChanged {
    return this.UnionKey === "OnUserPresenceActivityChanged";
  }
  public isOnUserPresenceActivityRemoved(): this is OnUserPresenceActivityRemoved {
    return this.UnionKey === "OnUserPresenceActivityRemoved";
  }
  public isUserChangedStatus(): this is UserChangedStatus {
    return this.UnionKey === "UserChangedStatus";
  }
  public isMessageSent(): this is MessageSent {
    return this.UnionKey === "MessageSent";
  }

}


export class ArchetypeChanged extends IArgonEvent
{
  constructor(public spaceId: guid, public data: Archetype) { super(); }

  UnionKey: string = "ArchetypeChanged";
  UnionIndex: number = 0;
}

export class ArchetypeCreated extends IArgonEvent
{
  constructor(public spaceId: guid, public data: Archetype) { super(); }

  UnionKey: string = "ArchetypeCreated";
  UnionIndex: number = 1;
}

export class ChannelCreated extends IArgonEvent
{
  constructor(public spaceId: guid, public data: ArgonChannel) { super(); }

  UnionKey: string = "ChannelCreated";
  UnionIndex: number = 2;
}

export class ChannelModified extends IArgonEvent
{
  constructor(public spaceId: guid, public channelId: guid, public bag: IonArray<string>) { super(); }

  UnionKey: string = "ChannelModified";
  UnionIndex: number = 3;
}

export class ChannelRemoved extends IArgonEvent
{
  constructor(public spaceId: guid, public channelId: guid) { super(); }

  UnionKey: string = "ChannelRemoved";
  UnionIndex: number = 4;
}

export class IAmTypingEvent extends IArgonEvent
{
  constructor(public spaceId: guid, public channelId: guid) { super(); }

  UnionKey: string = "IAmTypingEvent";
  UnionIndex: number = 5;
}

export class IAmStopTypingEvent extends IArgonEvent
{
  constructor(public spaceId: guid, public channelId: guid) { super(); }

  UnionKey: string = "IAmStopTypingEvent";
  UnionIndex: number = 6;
}

export class UserTypingEvent extends IArgonEvent
{
  constructor(public spaceId: guid, public channelId: guid, public userId: guid) { super(); }

  UnionKey: string = "UserTypingEvent";
  UnionIndex: number = 7;
}

export class UserStopTypingEvent extends IArgonEvent
{
  constructor(public spaceId: guid, public channelId: guid, public userId: guid) { super(); }

  UnionKey: string = "UserStopTypingEvent";
  UnionIndex: number = 8;
}

export class JoinedToChannelUser extends IArgonEvent
{
  constructor(public spaceId: guid, public channelId: guid, public userId: guid) { super(); }

  UnionKey: string = "JoinedToChannelUser";
  UnionIndex: number = 9;
}

export class JoinToServerUser extends IArgonEvent
{
  constructor(public spaceId: guid, public userId: guid) { super(); }

  UnionKey: string = "JoinToServerUser";
  UnionIndex: number = 10;
}

export class LeavedFromChannelUser extends IArgonEvent
{
  constructor(public spaceId: guid, public channelId: guid, public userId: guid) { super(); }

  UnionKey: string = "LeavedFromChannelUser";
  UnionIndex: number = 11;
}

export class UserUpdated extends IArgonEvent
{
  constructor(public spaceId: guid, public dto: ArgonUser) { super(); }

  UnionKey: string = "UserUpdated";
  UnionIndex: number = 12;
}

export class OnUserPresenceActivityChanged extends IArgonEvent
{
  constructor(public spaceId: guid, public userId: guid, public presence: UserActivityPresence) { super(); }

  UnionKey: string = "OnUserPresenceActivityChanged";
  UnionIndex: number = 13;
}

export class OnUserPresenceActivityRemoved extends IArgonEvent
{
  constructor(public spaceId: guid, public userId: guid) { super(); }

  UnionKey: string = "OnUserPresenceActivityRemoved";
  UnionIndex: number = 14;
}

export class UserChangedStatus extends IArgonEvent
{
  constructor(public spaceId: guid, public userId: guid, public status: UserStatus, public bag: IonArray<string>) { super(); }

  UnionKey: string = "UserChangedStatus";
  UnionIndex: number = 15;
}

export class MessageSent extends IArgonEvent
{
  constructor(public spaceId: guid, public message: ArgonMessage) { super(); }

  UnionKey: string = "MessageSent";
  UnionIndex: number = 16;
}



IonFormatterStorage.register("IArgonEvent", {
  read(reader: CborReader): IArgonEvent {
    reader.readStartArray();
    let value: IArgonEvent = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<ArchetypeChanged>("ArchetypeChanged").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<ArchetypeCreated>("ArchetypeCreated").read(reader);
    else if (unionIndex == 2)
      value = IonFormatterStorage.get<ChannelCreated>("ChannelCreated").read(reader);
    else if (unionIndex == 3)
      value = IonFormatterStorage.get<ChannelModified>("ChannelModified").read(reader);
    else if (unionIndex == 4)
      value = IonFormatterStorage.get<ChannelRemoved>("ChannelRemoved").read(reader);
    else if (unionIndex == 5)
      value = IonFormatterStorage.get<IAmTypingEvent>("IAmTypingEvent").read(reader);
    else if (unionIndex == 6)
      value = IonFormatterStorage.get<IAmStopTypingEvent>("IAmStopTypingEvent").read(reader);
    else if (unionIndex == 7)
      value = IonFormatterStorage.get<UserTypingEvent>("UserTypingEvent").read(reader);
    else if (unionIndex == 8)
      value = IonFormatterStorage.get<UserStopTypingEvent>("UserStopTypingEvent").read(reader);
    else if (unionIndex == 9)
      value = IonFormatterStorage.get<JoinedToChannelUser>("JoinedToChannelUser").read(reader);
    else if (unionIndex == 10)
      value = IonFormatterStorage.get<JoinToServerUser>("JoinToServerUser").read(reader);
    else if (unionIndex == 11)
      value = IonFormatterStorage.get<LeavedFromChannelUser>("LeavedFromChannelUser").read(reader);
    else if (unionIndex == 12)
      value = IonFormatterStorage.get<UserUpdated>("UserUpdated").read(reader);
    else if (unionIndex == 13)
      value = IonFormatterStorage.get<OnUserPresenceActivityChanged>("OnUserPresenceActivityChanged").read(reader);
    else if (unionIndex == 14)
      value = IonFormatterStorage.get<OnUserPresenceActivityRemoved>("OnUserPresenceActivityRemoved").read(reader);
    else if (unionIndex == 15)
      value = IonFormatterStorage.get<UserChangedStatus>("UserChangedStatus").read(reader);
    else if (unionIndex == 16)
      value = IonFormatterStorage.get<MessageSent>("MessageSent").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IArgonEvent): void {
    writer.writeStartArray(null);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0)
      IonFormatterStorage.get<ArchetypeChanged>("ArchetypeChanged").write(writer, value as ArchetypeChanged);
    else if (value.UnionIndex == 1)
      IonFormatterStorage.get<ArchetypeCreated>("ArchetypeCreated").write(writer, value as ArchetypeCreated);
    else if (value.UnionIndex == 2)
      IonFormatterStorage.get<ChannelCreated>("ChannelCreated").write(writer, value as ChannelCreated);
    else if (value.UnionIndex == 3)
      IonFormatterStorage.get<ChannelModified>("ChannelModified").write(writer, value as ChannelModified);
    else if (value.UnionIndex == 4)
      IonFormatterStorage.get<ChannelRemoved>("ChannelRemoved").write(writer, value as ChannelRemoved);
    else if (value.UnionIndex == 5)
      IonFormatterStorage.get<IAmTypingEvent>("IAmTypingEvent").write(writer, value as IAmTypingEvent);
    else if (value.UnionIndex == 6)
      IonFormatterStorage.get<IAmStopTypingEvent>("IAmStopTypingEvent").write(writer, value as IAmStopTypingEvent);
    else if (value.UnionIndex == 7)
      IonFormatterStorage.get<UserTypingEvent>("UserTypingEvent").write(writer, value as UserTypingEvent);
    else if (value.UnionIndex == 8)
      IonFormatterStorage.get<UserStopTypingEvent>("UserStopTypingEvent").write(writer, value as UserStopTypingEvent);
    else if (value.UnionIndex == 9)
      IonFormatterStorage.get<JoinedToChannelUser>("JoinedToChannelUser").write(writer, value as JoinedToChannelUser);
    else if (value.UnionIndex == 10)
      IonFormatterStorage.get<JoinToServerUser>("JoinToServerUser").write(writer, value as JoinToServerUser);
    else if (value.UnionIndex == 11)
      IonFormatterStorage.get<LeavedFromChannelUser>("LeavedFromChannelUser").write(writer, value as LeavedFromChannelUser);
    else if (value.UnionIndex == 12)
      IonFormatterStorage.get<UserUpdated>("UserUpdated").write(writer, value as UserUpdated);
    else if (value.UnionIndex == 13)
      IonFormatterStorage.get<OnUserPresenceActivityChanged>("OnUserPresenceActivityChanged").write(writer, value as OnUserPresenceActivityChanged);
    else if (value.UnionIndex == 14)
      IonFormatterStorage.get<OnUserPresenceActivityRemoved>("OnUserPresenceActivityRemoved").write(writer, value as OnUserPresenceActivityRemoved);
    else if (value.UnionIndex == 15)
      IonFormatterStorage.get<UserChangedStatus>("UserChangedStatus").write(writer, value as UserChangedStatus);
    else if (value.UnionIndex == 16)
      IonFormatterStorage.get<MessageSent>("MessageSent").write(writer, value as MessageSent);
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("ArchetypeChanged", {
  read(reader: CborReader): ArchetypeChanged {
    reader.readStartArray();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const data = IonFormatterStorage.get<Archetype>('Archetype').read(reader);
    reader.readEndArray();
    return new ArchetypeChanged(spaceId, data);
  },
  write(writer: CborWriter, value: ArchetypeChanged): void {
    writer.writeStartArray(null);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<Archetype>('Archetype').write(writer, value.data);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ArchetypeCreated", {
  read(reader: CborReader): ArchetypeCreated {
    reader.readStartArray();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const data = IonFormatterStorage.get<Archetype>('Archetype').read(reader);
    reader.readEndArray();
    return new ArchetypeCreated(spaceId, data);
  },
  write(writer: CborWriter, value: ArchetypeCreated): void {
    writer.writeStartArray(null);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<Archetype>('Archetype').write(writer, value.data);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ChannelCreated", {
  read(reader: CborReader): ChannelCreated {
    reader.readStartArray();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const data = IonFormatterStorage.get<ArgonChannel>('ArgonChannel').read(reader);
    reader.readEndArray();
    return new ChannelCreated(spaceId, data);
  },
  write(writer: CborWriter, value: ChannelCreated): void {
    writer.writeStartArray(null);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<ArgonChannel>('ArgonChannel').write(writer, value.data);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ChannelModified", {
  read(reader: CborReader): ChannelModified {
    reader.readStartArray();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const channelId = IonFormatterStorage.get<guid>('guid').read(reader);
    const bag = IonFormatterStorage.readArray<string>(reader, 'string');
    reader.readEndArray();
    return new ChannelModified(spaceId, channelId, bag);
  },
  write(writer: CborWriter, value: ChannelModified): void {
    writer.writeStartArray(null);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.channelId);
    IonFormatterStorage.writeArray<string>(writer, value.bag, 'string');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("ChannelRemoved", {
  read(reader: CborReader): ChannelRemoved {
    reader.readStartArray();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const channelId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArray();
    return new ChannelRemoved(spaceId, channelId);
  },
  write(writer: CborWriter, value: ChannelRemoved): void {
    writer.writeStartArray(null);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.channelId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("IAmTypingEvent", {
  read(reader: CborReader): IAmTypingEvent {
    reader.readStartArray();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const channelId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArray();
    return new IAmTypingEvent(spaceId, channelId);
  },
  write(writer: CborWriter, value: IAmTypingEvent): void {
    writer.writeStartArray(null);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.channelId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("IAmStopTypingEvent", {
  read(reader: CborReader): IAmStopTypingEvent {
    reader.readStartArray();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const channelId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArray();
    return new IAmStopTypingEvent(spaceId, channelId);
  },
  write(writer: CborWriter, value: IAmStopTypingEvent): void {
    writer.writeStartArray(null);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.channelId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("UserTypingEvent", {
  read(reader: CborReader): UserTypingEvent {
    reader.readStartArray();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const channelId = IonFormatterStorage.get<guid>('guid').read(reader);
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArray();
    return new UserTypingEvent(spaceId, channelId, userId);
  },
  write(writer: CborWriter, value: UserTypingEvent): void {
    writer.writeStartArray(null);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.channelId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("UserStopTypingEvent", {
  read(reader: CborReader): UserStopTypingEvent {
    reader.readStartArray();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const channelId = IonFormatterStorage.get<guid>('guid').read(reader);
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArray();
    return new UserStopTypingEvent(spaceId, channelId, userId);
  },
  write(writer: CborWriter, value: UserStopTypingEvent): void {
    writer.writeStartArray(null);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.channelId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("JoinedToChannelUser", {
  read(reader: CborReader): JoinedToChannelUser {
    reader.readStartArray();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const channelId = IonFormatterStorage.get<guid>('guid').read(reader);
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArray();
    return new JoinedToChannelUser(spaceId, channelId, userId);
  },
  write(writer: CborWriter, value: JoinedToChannelUser): void {
    writer.writeStartArray(null);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.channelId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("JoinToServerUser", {
  read(reader: CborReader): JoinToServerUser {
    reader.readStartArray();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArray();
    return new JoinToServerUser(spaceId, userId);
  },
  write(writer: CborWriter, value: JoinToServerUser): void {
    writer.writeStartArray(null);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("LeavedFromChannelUser", {
  read(reader: CborReader): LeavedFromChannelUser {
    reader.readStartArray();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const channelId = IonFormatterStorage.get<guid>('guid').read(reader);
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArray();
    return new LeavedFromChannelUser(spaceId, channelId, userId);
  },
  write(writer: CborWriter, value: LeavedFromChannelUser): void {
    writer.writeStartArray(null);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.channelId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("UserUpdated", {
  read(reader: CborReader): UserUpdated {
    reader.readStartArray();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const dto = IonFormatterStorage.get<ArgonUser>('ArgonUser').read(reader);
    reader.readEndArray();
    return new UserUpdated(spaceId, dto);
  },
  write(writer: CborWriter, value: UserUpdated): void {
    writer.writeStartArray(null);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<ArgonUser>('ArgonUser').write(writer, value.dto);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("OnUserPresenceActivityChanged", {
  read(reader: CborReader): OnUserPresenceActivityChanged {
    reader.readStartArray();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    const presence = IonFormatterStorage.get<UserActivityPresence>('UserActivityPresence').read(reader);
    reader.readEndArray();
    return new OnUserPresenceActivityChanged(spaceId, userId, presence);
  },
  write(writer: CborWriter, value: OnUserPresenceActivityChanged): void {
    writer.writeStartArray(null);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    IonFormatterStorage.get<UserActivityPresence>('UserActivityPresence').write(writer, value.presence);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("OnUserPresenceActivityRemoved", {
  read(reader: CborReader): OnUserPresenceActivityRemoved {
    reader.readStartArray();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    reader.readEndArray();
    return new OnUserPresenceActivityRemoved(spaceId, userId);
  },
  write(writer: CborWriter, value: OnUserPresenceActivityRemoved): void {
    writer.writeStartArray(null);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("UserChangedStatus", {
  read(reader: CborReader): UserChangedStatus {
    reader.readStartArray();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const userId = IonFormatterStorage.get<guid>('guid').read(reader);
    const status = IonFormatterStorage.get<UserStatus>('UserStatus').read(reader);
    const bag = IonFormatterStorage.readArray<string>(reader, 'string');
    reader.readEndArray();
    return new UserChangedStatus(spaceId, userId, status, bag);
  },
  write(writer: CborWriter, value: UserChangedStatus): void {
    writer.writeStartArray(null);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, value.userId);
    IonFormatterStorage.get<UserStatus>('UserStatus').write(writer, value.status);
    IonFormatterStorage.writeArray<string>(writer, value.bag, 'string');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("MessageSent", {
  read(reader: CborReader): MessageSent {
    reader.readStartArray();
    const spaceId = IonFormatterStorage.get<guid>('guid').read(reader);
    const message = IonFormatterStorage.get<ArgonMessage>('ArgonMessage').read(reader);
    reader.readEndArray();
    return new MessageSent(spaceId, message);
  },
  write(writer: CborWriter, value: MessageSent): void {
    writer.writeStartArray(null);
    IonFormatterStorage.get<guid>('guid').write(writer, value.spaceId);
    IonFormatterStorage.get<ArgonMessage>('ArgonMessage').write(writer, value.message);
    writer.writeEndArray();
  }
});



export abstract class IAuthorizeResult implements IIonUnion<IAuthorizeResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessAuthorize(): this is SuccessAuthorize {
    return this.UnionKey === "SuccessAuthorize";
  }
  public isFailedAuthorize(): this is FailedAuthorize {
    return this.UnionKey === "FailedAuthorize";
  }

}


export class SuccessAuthorize extends IAuthorizeResult
{
  constructor(public token: string, public refreshToken: IonMaybe<string>) { super(); }

  UnionKey: string = "SuccessAuthorize";
  UnionIndex: number = 0;
}

export class FailedAuthorize extends IAuthorizeResult
{
  constructor(public error: AuthorizationError) { super(); }

  UnionKey: string = "FailedAuthorize";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("IAuthorizeResult", {
  read(reader: CborReader): IAuthorizeResult {
    reader.readStartArray();
    let value: IAuthorizeResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessAuthorize>("SuccessAuthorize").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<FailedAuthorize>("FailedAuthorize").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IAuthorizeResult): void {
    writer.writeStartArray(null);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0)
      IonFormatterStorage.get<SuccessAuthorize>("SuccessAuthorize").write(writer, value as SuccessAuthorize);
    else if (value.UnionIndex == 1)
      IonFormatterStorage.get<FailedAuthorize>("FailedAuthorize").write(writer, value as FailedAuthorize);
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessAuthorize", {
  read(reader: CborReader): SuccessAuthorize {
    reader.readStartArray();
    const token = IonFormatterStorage.get<string>('string').read(reader);
    const refreshToken = IonFormatterStorage.readMaybe<string>(reader, 'string');
    reader.readEndArray();
    return new SuccessAuthorize(token, refreshToken);
  },
  write(writer: CborWriter, value: SuccessAuthorize): void {
    writer.writeStartArray(null);
    IonFormatterStorage.get<string>('string').write(writer, value.token);
    IonFormatterStorage.writeMaybe<string>(writer, value.refreshToken, 'string');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FailedAuthorize", {
  read(reader: CborReader): FailedAuthorize {
    reader.readStartArray();
    const error = IonFormatterStorage.get<AuthorizationError>('AuthorizationError').read(reader);
    reader.readEndArray();
    return new FailedAuthorize(error);
  },
  write(writer: CborWriter, value: FailedAuthorize): void {
    writer.writeStartArray(null);
    IonFormatterStorage.get<AuthorizationError>('AuthorizationError').write(writer, value.error);
    writer.writeEndArray();
  }
});



export abstract class IRegistrationResult implements IIonUnion<IRegistrationResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessRegistration(): this is SuccessRegistration {
    return this.UnionKey === "SuccessRegistration";
  }
  public isFailedRegistration(): this is FailedRegistration {
    return this.UnionKey === "FailedRegistration";
  }

}


export class SuccessRegistration extends IRegistrationResult
{
  constructor(public token: string, public refreshToken: IonMaybe<string>) { super(); }

  UnionKey: string = "SuccessRegistration";
  UnionIndex: number = 0;
}

export class FailedRegistration extends IRegistrationResult
{
  constructor(public error: RegistrationError, public field: IonMaybe<string>, public message: IonMaybe<string>) { super(); }

  UnionKey: string = "FailedRegistration";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("IRegistrationResult", {
  read(reader: CborReader): IRegistrationResult {
    reader.readStartArray();
    let value: IRegistrationResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessRegistration>("SuccessRegistration").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<FailedRegistration>("FailedRegistration").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IRegistrationResult): void {
    writer.writeStartArray(null);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0)
      IonFormatterStorage.get<SuccessRegistration>("SuccessRegistration").write(writer, value as SuccessRegistration);
    else if (value.UnionIndex == 1)
      IonFormatterStorage.get<FailedRegistration>("FailedRegistration").write(writer, value as FailedRegistration);
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessRegistration", {
  read(reader: CborReader): SuccessRegistration {
    reader.readStartArray();
    const token = IonFormatterStorage.get<string>('string').read(reader);
    const refreshToken = IonFormatterStorage.readMaybe<string>(reader, 'string');
    reader.readEndArray();
    return new SuccessRegistration(token, refreshToken);
  },
  write(writer: CborWriter, value: SuccessRegistration): void {
    writer.writeStartArray(null);
    IonFormatterStorage.get<string>('string').write(writer, value.token);
    IonFormatterStorage.writeMaybe<string>(writer, value.refreshToken, 'string');
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FailedRegistration", {
  read(reader: CborReader): FailedRegistration {
    reader.readStartArray();
    const error = IonFormatterStorage.get<RegistrationError>('RegistrationError').read(reader);
    const field = IonFormatterStorage.readMaybe<string>(reader, 'string');
    const message = IonFormatterStorage.readMaybe<string>(reader, 'string');
    reader.readEndArray();
    return new FailedRegistration(error, field, message);
  },
  write(writer: CborWriter, value: FailedRegistration): void {
    writer.writeStartArray(null);
    IonFormatterStorage.get<RegistrationError>('RegistrationError').write(writer, value.error);
    IonFormatterStorage.writeMaybe<string>(writer, value.field, 'string');
    IonFormatterStorage.writeMaybe<string>(writer, value.message, 'string');
    writer.writeEndArray();
  }
});



export abstract class IJoinToSpaceResult implements IIonUnion<IJoinToSpaceResult>
{
  abstract UnionKey: string;
  abstract UnionIndex: number;
  
  
  
  
  public isSuccessJoin(): this is SuccessJoin {
    return this.UnionKey === "SuccessJoin";
  }
  public isFailedJoin(): this is FailedJoin {
    return this.UnionKey === "FailedJoin";
  }

}


export class SuccessJoin extends IJoinToSpaceResult
{
  constructor(public space: ArgonSpace) { super(); }

  UnionKey: string = "SuccessJoin";
  UnionIndex: number = 0;
}

export class FailedJoin extends IJoinToSpaceResult
{
  constructor(public error: AcceptInviteError) { super(); }

  UnionKey: string = "FailedJoin";
  UnionIndex: number = 1;
}



IonFormatterStorage.register("IJoinToSpaceResult", {
  read(reader: CborReader): IJoinToSpaceResult {
    reader.readStartArray();
    let value: IJoinToSpaceResult = null as any;
    const unionIndex = reader.readUInt32();
    
    if (false)
    {}
        else if (unionIndex == 0)
      value = IonFormatterStorage.get<SuccessJoin>("SuccessJoin").read(reader);
    else if (unionIndex == 1)
      value = IonFormatterStorage.get<FailedJoin>("FailedJoin").read(reader);

    else throw new Error();
  
    reader.readEndArray();
    return value!;
  },
  write(writer: CborWriter, value: IJoinToSpaceResult): void {
    writer.writeStartArray(null);
    writer.writeUInt32(value.UnionIndex);
    if (false)
    {}
        else if (value.UnionIndex == 0)
      IonFormatterStorage.get<SuccessJoin>("SuccessJoin").write(writer, value as SuccessJoin);
    else if (value.UnionIndex == 1)
      IonFormatterStorage.get<FailedJoin>("FailedJoin").write(writer, value as FailedJoin);
  
    else throw new Error();
    writer.writeEndArray();
  }
});


IonFormatterStorage.register("SuccessJoin", {
  read(reader: CborReader): SuccessJoin {
    reader.readStartArray();
    const space = IonFormatterStorage.get<ArgonSpace>('ArgonSpace').read(reader);
    reader.readEndArray();
    return new SuccessJoin(space);
  },
  write(writer: CborWriter, value: SuccessJoin): void {
    writer.writeStartArray(null);
    IonFormatterStorage.get<ArgonSpace>('ArgonSpace').write(writer, value.space);
    writer.writeEndArray();
  }
});

IonFormatterStorage.register("FailedJoin", {
  read(reader: CborReader): FailedJoin {
    reader.readStartArray();
    const error = IonFormatterStorage.get<AcceptInviteError>('AcceptInviteError').read(reader);
    reader.readEndArray();
    return new FailedJoin(error);
  },
  write(writer: CborWriter, value: FailedJoin): void {
    writer.writeStartArray(null);
    IonFormatterStorage.get<AcceptInviteError>('AcceptInviteError').write(writer, value.error);
    writer.writeEndArray();
  }
});




export interface IArchetypeInteraction extends IIonService
{
  GetServerArchetypes(spaceId: guid): Promise<IonArray<Archetype>>;
  CreateArchetype(spaceId: guid, name: string): Promise<Archetype>;
  UpdateArchetype(spaceId: guid, data: Archetype): Promise<Archetype>;
  SetArchetypeToMember(spaceId: guid, memberId: guid, archetypeId: guid, isGrant: bool): Promise<bool>;
  GetDetailedServerArchetypes(spaceId: guid): Promise<IonArray<ArchetypeGroup>>;
  UpsertArchetypeEntitlementForChannel(spaceId: guid, channelId: guid, archetypeId: guid, deny: ArgonEntitlement, allow: ArgonEntitlement): Promise<IonMaybe<ChannelEntitlementOverwrite>>;
}




export interface IChannelInteraction extends IIonService
{
  CreateChannel(spaceId: guid, channelId: guid, request: CreateChannelRequest): Promise<void>;
  DeleteChannel(spaceId: guid, channelId: guid): Promise<void>;
  GetChannels(spaceId: guid, channelId: guid): Promise<IonArray<RealtimeChannel>>;
  QueryMessages(spaceId: guid, channelId: guid, from: IonMaybe<u8>, limit: i4): Promise<IonArray<ArgonMessage>>;
  SendMessage(spaceId: guid, channelId: guid, text: string, entities: IonArray<IMessageEntity>, replyTo: IonMaybe<u8>): Promise<ArgonMessage>;
  GetMessages(spaceId: guid, channelId: guid, count: i4, offset: u8): Promise<IonArray<ArgonMessage>>;
  DisconnectFromVoiceChannel(spaceId: guid, channelId: guid): Promise<void>;
  JoinToVoiceChannel(spaceId: guid, channelId: guid): Promise<IJoinToVoiceResult>;
  KickMemberFromChannel(spaceId: guid, channelId: guid, memberId: guid): Promise<bool>;
}


export interface IEventBus extends IIonService
{
  ForServer(spaceId: guid): AsyncIterable<IArgonEvent>;
  ForSelf(): AsyncIterable<IArgonEvent>;
}




export interface IServerInteraction extends IIonService
{
  GetMembers(spaceId: guid): Promise<IonArray<RealtimeServerMember>>;
  GetMember(spaceId: guid, userId: guid): Promise<RealtimeServerMember>;
  GetInviteCodes(spaceId: guid): Promise<IonArray<InviteCodeEntity>>;
  CreateInviteCode(spaceId: guid): Promise<InviteCode>;
  PrefetchUser(spaceId: guid, userId: guid): Promise<ArgonUser>;
  PrefetchProfile(spaceId: guid, userId: guid): Promise<ArgonUserProfile>;
  GetChannels(spaceId: guid): Promise<IonArray<RealtimeChannel>>;
  GetServerArchetypes(spaceId: guid): Promise<IonArray<Archetype>>;
  GetDetailedServerArchetypes(spaceId: guid): Promise<IonArray<ArchetypeGroup>>;
}




export interface IUserInteraction extends IIonService
{
  GetMe(): Promise<ArgonUser>;
  CreateSpace(request: CreateServerRequest): Promise<ArgonSpace>;
  GetSpaces(): Promise<IonArray<ArgonSpace>>;
  Authorize(data: UserCredentialsInput): Promise<IAuthorizeResult>;
  Registration(data: NewUserCredentialsInput): Promise<IRegistrationResult>;
  BeginResetPassword(email: string): Promise<bool>;
  ResetPassword(email: string, otpCode: string, newPassword: string): Promise<IAuthorizeResult>;
  JoinToSpace(inviteCode: InviteCode): Promise<IJoinToSpaceResult>;
  BroadcastPresence(presence: UserActivityPresence): Promise<void>;
  RemoveBroadcastPresence(): Promise<void>;
  GetMyFeatures(): Promise<IonArray<FeatureFlag>>;
}




export interface IVoiceInteraction extends IIonService
{
  DisconnectFromVoiceChannel(spaceId: guid, channelId: guid): Promise<bool>;
  KickMemberFromChannel(spaceId: guid, channelId: guid, memberId: guid): Promise<void>;
}




export interface IArchetypeInteraction extends IIonService
{
  GetServerArchetypes(spaceId: guid): Promise<IonArray<Archetype>>;
  CreateArchetype(spaceId: guid, name: string): Promise<Archetype>;
  UpdateArchetype(spaceId: guid, data: Archetype): Promise<Archetype>;
  SetArchetypeToMember(spaceId: guid, memberId: guid, archetypeId: guid, isGrant: bool): Promise<bool>;
  GetDetailedServerArchetypes(spaceId: guid): Promise<IonArray<ArchetypeGroup>>;
  UpsertArchetypeEntitlementForChannel(spaceId: guid, channelId: guid, archetypeId: guid, deny: ArgonEntitlement, allow: ArgonEntitlement): Promise<IonMaybe<ChannelEntitlementOverwrite>>;
}




export interface IChannelInteraction extends IIonService
{
  CreateChannel(spaceId: guid, channelId: guid, request: CreateChannelRequest): Promise<void>;
  DeleteChannel(spaceId: guid, channelId: guid): Promise<void>;
  GetChannels(spaceId: guid, channelId: guid): Promise<IonArray<RealtimeChannel>>;
  QueryMessages(spaceId: guid, channelId: guid, from: IonMaybe<u8>, limit: i4): Promise<IonArray<ArgonMessage>>;
  SendMessage(spaceId: guid, channelId: guid, text: string, entities: IonArray<IMessageEntity>, replyTo: IonMaybe<u8>): Promise<ArgonMessage>;
  GetMessages(spaceId: guid, channelId: guid, count: i4, offset: u8): Promise<IonArray<ArgonMessage>>;
  DisconnectFromVoiceChannel(spaceId: guid, channelId: guid): Promise<void>;
  JoinToVoiceChannel(spaceId: guid, channelId: guid): Promise<IJoinToVoiceResult>;
  KickMemberFromChannel(spaceId: guid, channelId: guid, memberId: guid): Promise<bool>;
}


export interface IEventBus extends IIonService
{
  ForServer(spaceId: guid): AsyncIterable<IArgonEvent>;
  ForSelf(): AsyncIterable<IArgonEvent>;
}




export interface IServerInteraction extends IIonService
{
  GetMembers(spaceId: guid): Promise<IonArray<RealtimeServerMember>>;
  GetMember(spaceId: guid, userId: guid): Promise<RealtimeServerMember>;
  GetInviteCodes(spaceId: guid): Promise<IonArray<InviteCodeEntity>>;
  CreateInviteCode(spaceId: guid): Promise<InviteCode>;
  PrefetchUser(spaceId: guid, userId: guid): Promise<ArgonUser>;
  PrefetchProfile(spaceId: guid, userId: guid): Promise<ArgonUserProfile>;
  GetChannels(spaceId: guid): Promise<IonArray<RealtimeChannel>>;
  GetServerArchetypes(spaceId: guid): Promise<IonArray<Archetype>>;
  GetDetailedServerArchetypes(spaceId: guid): Promise<IonArray<ArchetypeGroup>>;
}




export interface IUserInteraction extends IIonService
{
  GetMe(): Promise<ArgonUser>;
  CreateSpace(request: CreateServerRequest): Promise<ArgonSpace>;
  GetSpaces(): Promise<IonArray<ArgonSpace>>;
  Authorize(data: UserCredentialsInput): Promise<IAuthorizeResult>;
  Registration(data: NewUserCredentialsInput): Promise<IRegistrationResult>;
  BeginResetPassword(email: string): Promise<bool>;
  ResetPassword(email: string, otpCode: string, newPassword: string): Promise<IAuthorizeResult>;
  JoinToSpace(inviteCode: InviteCode): Promise<IJoinToSpaceResult>;
  BroadcastPresence(presence: UserActivityPresence): Promise<void>;
  RemoveBroadcastPresence(): Promise<void>;
  GetMyFeatures(): Promise<IonArray<FeatureFlag>>;
}




export interface IVoiceInteraction extends IIonService
{
  DisconnectFromVoiceChannel(spaceId: guid, channelId: guid): Promise<bool>;
  KickMemberFromChannel(spaceId: guid, channelId: guid, memberId: guid): Promise<void>;
}



//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a code generation tool.
//     Changes to this file may cause incorrect behavior and will be lost
//     if the code is regenerated.
//
//     Generator: IonPath Codegen
// </auto-generated>
//------------------------------------------------------------------------------

export class ArchetypeInteraction_Executor extends ServiceExecutor<IArchetypeInteraction> implements IArchetypeInteraction {
  constructor(public ctx: IonClientContext, private signal: AbortSignal) {
      super();
  }

  
  async GetServerArchetypes(spaceId: guid): Promise<IonArray<Archetype>> {
    const req = new IonRequest(this.ctx, "IArchetypeInteraction", "GetServerArchetypes");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<Archetype>>("IonArray<Archetype>", writer.data, this.signal);
  }
  async CreateArchetype(spaceId: guid, name: string): Promise<Archetype> {
    const req = new IonRequest(this.ctx, "IArchetypeInteraction", "CreateArchetype");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<string>('string').write(writer, name);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<Archetype>("Archetype", writer.data, this.signal);
  }
  async UpdateArchetype(spaceId: guid, data: Archetype): Promise<Archetype> {
    const req = new IonRequest(this.ctx, "IArchetypeInteraction", "UpdateArchetype");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<Archetype>('Archetype').write(writer, data);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<Archetype>("Archetype", writer.data, this.signal);
  }
  async SetArchetypeToMember(spaceId: guid, memberId: guid, archetypeId: guid, isGrant: bool): Promise<bool> {
    const req = new IonRequest(this.ctx, "IArchetypeInteraction", "SetArchetypeToMember");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(4);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, memberId);
    IonFormatterStorage.get<guid>('guid').write(writer, archetypeId);
    IonFormatterStorage.get<bool>('bool').write(writer, isGrant);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }
  async GetDetailedServerArchetypes(spaceId: guid): Promise<IonArray<ArchetypeGroup>> {
    const req = new IonRequest(this.ctx, "IArchetypeInteraction", "GetDetailedServerArchetypes");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<ArchetypeGroup>>("IonArray<ArchetypeGroup>", writer.data, this.signal);
  }
  async UpsertArchetypeEntitlementForChannel(spaceId: guid, channelId: guid, archetypeId: guid, deny: ArgonEntitlement, allow: ArgonEntitlement): Promise<IonMaybe<ChannelEntitlementOverwrite>> {
    const req = new IonRequest(this.ctx, "IArchetypeInteraction", "UpsertArchetypeEntitlementForChannel");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(5);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
    IonFormatterStorage.get<guid>('guid').write(writer, archetypeId);
    IonFormatterStorage.get<ArgonEntitlement>('ArgonEntitlement').write(writer, deny);
    IonFormatterStorage.get<ArgonEntitlement>('ArgonEntitlement').write(writer, allow);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonMaybe<ChannelEntitlementOverwrite>>("IonMaybe<ChannelEntitlementOverwrite>", writer.data, this.signal);
  }

}

IonFormatterStorage.registerClientExecutor<IArchetypeInteraction>('ArchetypeInteraction', ArchetypeInteraction_Executor);

export class ChannelInteraction_Executor extends ServiceExecutor<IChannelInteraction> implements IChannelInteraction {
  constructor(public ctx: IonClientContext, private signal: AbortSignal) {
      super();
  }

  
  async CreateChannel(spaceId: guid, channelId: guid, request: CreateChannelRequest): Promise<void> {
    const req = new IonRequest(this.ctx, "IChannelInteraction", "CreateChannel");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(3);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
    IonFormatterStorage.get<CreateChannelRequest>('CreateChannelRequest').write(writer, request);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async DeleteChannel(spaceId: guid, channelId: guid): Promise<void> {
    const req = new IonRequest(this.ctx, "IChannelInteraction", "DeleteChannel");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async GetChannels(spaceId: guid, channelId: guid): Promise<IonArray<RealtimeChannel>> {
    const req = new IonRequest(this.ctx, "IChannelInteraction", "GetChannels");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<RealtimeChannel>>("IonArray<RealtimeChannel>", writer.data, this.signal);
  }
  async QueryMessages(spaceId: guid, channelId: guid, from: IonMaybe<u8>, limit: i4): Promise<IonArray<ArgonMessage>> {
    const req = new IonRequest(this.ctx, "IChannelInteraction", "QueryMessages");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(4);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
    IonFormatterStorage.writeMaybe<u8>(writer, from, 'u8');
    IonFormatterStorage.get<i4>('i4').write(writer, limit);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<ArgonMessage>>("IonArray<ArgonMessage>", writer.data, this.signal);
  }
  async SendMessage(spaceId: guid, channelId: guid, text: string, entities: IonArray<IMessageEntity>, replyTo: IonMaybe<u8>): Promise<ArgonMessage> {
    const req = new IonRequest(this.ctx, "IChannelInteraction", "SendMessage");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(5);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
    IonFormatterStorage.get<string>('string').write(writer, text);
    IonFormatterStorage.writeArray<IMessageEntity>(writer, entities, 'IMessageEntity');
    IonFormatterStorage.writeMaybe<u8>(writer, replyTo, 'u8');
      
    writer.writeEndArray();
          
    return await req.callAsyncT<ArgonMessage>("ArgonMessage", writer.data, this.signal);
  }
  async GetMessages(spaceId: guid, channelId: guid, count: i4, offset: u8): Promise<IonArray<ArgonMessage>> {
    const req = new IonRequest(this.ctx, "IChannelInteraction", "GetMessages");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(4);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
    IonFormatterStorage.get<i4>('i4').write(writer, count);
    IonFormatterStorage.get<u8>('u8').write(writer, offset);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<ArgonMessage>>("IonArray<ArgonMessage>", writer.data, this.signal);
  }
  async DisconnectFromVoiceChannel(spaceId: guid, channelId: guid): Promise<void> {
    const req = new IonRequest(this.ctx, "IChannelInteraction", "DisconnectFromVoiceChannel");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async JoinToVoiceChannel(spaceId: guid, channelId: guid): Promise<IJoinToVoiceResult> {
    const req = new IonRequest(this.ctx, "IChannelInteraction", "JoinToVoiceChannel");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IJoinToVoiceResult>("IJoinToVoiceResult", writer.data, this.signal);
  }
  async KickMemberFromChannel(spaceId: guid, channelId: guid, memberId: guid): Promise<bool> {
    const req = new IonRequest(this.ctx, "IChannelInteraction", "KickMemberFromChannel");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(3);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
    IonFormatterStorage.get<guid>('guid').write(writer, memberId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }

}

IonFormatterStorage.registerClientExecutor<IChannelInteraction>('ChannelInteraction', ChannelInteraction_Executor);

export class EventBus_Executor extends ServiceExecutor<IEventBus> implements IEventBus {
  constructor(public ctx: IonClientContext, private signal: AbortSignal) {
      super();
  }

  
  ForServer(spaceId: guid): AsyncIterable<IArgonEvent> {
    const ws = new IonWsClient(this.ctx.baseUrl, "IEventBus", "ForServer");
    
    const writer = new CborWriter();
    
    writer.writeStartArray(1);
    
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    
    writer.writeEndArray();
    
    return ws.callServerStreaming<IArgonEvent>("IArgonEvent", writer.data, this.signal);
  }
  ForSelf(): AsyncIterable<IArgonEvent> {
    const ws = new IonWsClient(this.ctx.baseUrl, "IEventBus", "ForSelf");
    
    const writer = new CborWriter();
    
    writer.writeStartArray(0);
    
    
    
    writer.writeEndArray();
    
    return ws.callServerStreaming<IArgonEvent>("IArgonEvent", writer.data, this.signal);
  }

}

IonFormatterStorage.registerClientExecutor<IEventBus>('EventBus', EventBus_Executor);

export class ServerInteraction_Executor extends ServiceExecutor<IServerInteraction> implements IServerInteraction {
  constructor(public ctx: IonClientContext, private signal: AbortSignal) {
      super();
  }

  
  async GetMembers(spaceId: guid): Promise<IonArray<RealtimeServerMember>> {
    const req = new IonRequest(this.ctx, "IServerInteraction", "GetMembers");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<RealtimeServerMember>>("IonArray<RealtimeServerMember>", writer.data, this.signal);
  }
  async GetMember(spaceId: guid, userId: guid): Promise<RealtimeServerMember> {
    const req = new IonRequest(this.ctx, "IServerInteraction", "GetMember");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, userId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<RealtimeServerMember>("RealtimeServerMember", writer.data, this.signal);
  }
  async GetInviteCodes(spaceId: guid): Promise<IonArray<InviteCodeEntity>> {
    const req = new IonRequest(this.ctx, "IServerInteraction", "GetInviteCodes");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<InviteCodeEntity>>("IonArray<InviteCodeEntity>", writer.data, this.signal);
  }
  async CreateInviteCode(spaceId: guid): Promise<InviteCode> {
    const req = new IonRequest(this.ctx, "IServerInteraction", "CreateInviteCode");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<InviteCode>("InviteCode", writer.data, this.signal);
  }
  async PrefetchUser(spaceId: guid, userId: guid): Promise<ArgonUser> {
    const req = new IonRequest(this.ctx, "IServerInteraction", "PrefetchUser");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, userId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<ArgonUser>("ArgonUser", writer.data, this.signal);
  }
  async PrefetchProfile(spaceId: guid, userId: guid): Promise<ArgonUserProfile> {
    const req = new IonRequest(this.ctx, "IServerInteraction", "PrefetchProfile");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, userId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<ArgonUserProfile>("ArgonUserProfile", writer.data, this.signal);
  }
  async GetChannels(spaceId: guid): Promise<IonArray<RealtimeChannel>> {
    const req = new IonRequest(this.ctx, "IServerInteraction", "GetChannels");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<RealtimeChannel>>("IonArray<RealtimeChannel>", writer.data, this.signal);
  }
  async GetServerArchetypes(spaceId: guid): Promise<IonArray<Archetype>> {
    const req = new IonRequest(this.ctx, "IServerInteraction", "GetServerArchetypes");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<Archetype>>("IonArray<Archetype>", writer.data, this.signal);
  }
  async GetDetailedServerArchetypes(spaceId: guid): Promise<IonArray<ArchetypeGroup>> {
    const req = new IonRequest(this.ctx, "IServerInteraction", "GetDetailedServerArchetypes");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<ArchetypeGroup>>("IonArray<ArchetypeGroup>", writer.data, this.signal);
  }

}

IonFormatterStorage.registerClientExecutor<IServerInteraction>('ServerInteraction', ServerInteraction_Executor);

export class UserInteraction_Executor extends ServiceExecutor<IUserInteraction> implements IUserInteraction {
  constructor(public ctx: IonClientContext, private signal: AbortSignal) {
      super();
  }

  
  async GetMe(): Promise<ArgonUser> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "GetMe");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<ArgonUser>("ArgonUser", writer.data, this.signal);
  }
  async CreateSpace(request: CreateServerRequest): Promise<ArgonSpace> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "CreateSpace");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<CreateServerRequest>('CreateServerRequest').write(writer, request);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<ArgonSpace>("ArgonSpace", writer.data, this.signal);
  }
  async GetSpaces(): Promise<IonArray<ArgonSpace>> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "GetSpaces");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<ArgonSpace>>("IonArray<ArgonSpace>", writer.data, this.signal);
  }
  async Authorize(data: UserCredentialsInput): Promise<IAuthorizeResult> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "Authorize");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<UserCredentialsInput>('UserCredentialsInput').write(writer, data);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IAuthorizeResult>("IAuthorizeResult", writer.data, this.signal);
  }
  async Registration(data: NewUserCredentialsInput): Promise<IRegistrationResult> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "Registration");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<NewUserCredentialsInput>('NewUserCredentialsInput').write(writer, data);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IRegistrationResult>("IRegistrationResult", writer.data, this.signal);
  }
  async BeginResetPassword(email: string): Promise<bool> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "BeginResetPassword");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<string>('string').write(writer, email);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }
  async ResetPassword(email: string, otpCode: string, newPassword: string): Promise<IAuthorizeResult> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "ResetPassword");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(3);
          
    IonFormatterStorage.get<string>('string').write(writer, email);
    IonFormatterStorage.get<string>('string').write(writer, otpCode);
    IonFormatterStorage.get<string>('string').write(writer, newPassword);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IAuthorizeResult>("IAuthorizeResult", writer.data, this.signal);
  }
  async JoinToSpace(inviteCode: InviteCode): Promise<IJoinToSpaceResult> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "JoinToSpace");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<InviteCode>('InviteCode').write(writer, inviteCode);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IJoinToSpaceResult>("IJoinToSpaceResult", writer.data, this.signal);
  }
  async BroadcastPresence(presence: UserActivityPresence): Promise<void> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "BroadcastPresence");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(1);
          
    IonFormatterStorage.get<UserActivityPresence>('UserActivityPresence').write(writer, presence);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async RemoveBroadcastPresence(): Promise<void> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "RemoveBroadcastPresence");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }
  async GetMyFeatures(): Promise<IonArray<FeatureFlag>> {
    const req = new IonRequest(this.ctx, "IUserInteraction", "GetMyFeatures");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(0);
          
    
      
    writer.writeEndArray();
          
    return await req.callAsyncT<IonArray<FeatureFlag>>("IonArray<FeatureFlag>", writer.data, this.signal);
  }

}

IonFormatterStorage.registerClientExecutor<IUserInteraction>('UserInteraction', UserInteraction_Executor);

export class VoiceInteraction_Executor extends ServiceExecutor<IVoiceInteraction> implements IVoiceInteraction {
  constructor(public ctx: IonClientContext, private signal: AbortSignal) {
      super();
  }

  
  async DisconnectFromVoiceChannel(spaceId: guid, channelId: guid): Promise<bool> {
    const req = new IonRequest(this.ctx, "IVoiceInteraction", "DisconnectFromVoiceChannel");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(2);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
      
    writer.writeEndArray();
          
    return await req.callAsyncT<bool>("bool", writer.data, this.signal);
  }
  async KickMemberFromChannel(spaceId: guid, channelId: guid, memberId: guid): Promise<void> {
    const req = new IonRequest(this.ctx, "IVoiceInteraction", "KickMemberFromChannel");
          
    const writer = new CborWriter();
      
    writer.writeStartArray(3);
          
    IonFormatterStorage.get<guid>('guid').write(writer, spaceId);
    IonFormatterStorage.get<guid>('guid').write(writer, channelId);
    IonFormatterStorage.get<guid>('guid').write(writer, memberId);
      
    writer.writeEndArray();
          
    await req.callAsync(writer.data, this.signal);
  }

}

IonFormatterStorage.registerClientExecutor<IVoiceInteraction>('VoiceInteraction', VoiceInteraction_Executor);


export function createClient(endpoint: string, interceptors: IonInterceptor[]) {
  const ctx = {
    baseUrl: endpoint,
    interceptors: interceptors
  } as IonClientContext;

  return new Proxy(
    {},
    {
      get(_target, propKey) {
        if (typeof propKey !== "string") return undefined;
        if (propKey === "ArchetypeInteraction") return IonFormatterStorage.createExecutor("ArchetypeInteraction", ctx, new AbortSignal());
        if (propKey === "ChannelInteraction") return IonFormatterStorage.createExecutor("ChannelInteraction", ctx, new AbortSignal());
        if (propKey === "EventBus") return IonFormatterStorage.createExecutor("EventBus", ctx, new AbortSignal());
        if (propKey === "ServerInteraction") return IonFormatterStorage.createExecutor("ServerInteraction", ctx, new AbortSignal());
        if (propKey === "UserInteraction") return IonFormatterStorage.createExecutor("UserInteraction", ctx, new AbortSignal());
        if (propKey === "VoiceInteraction") return IonFormatterStorage.createExecutor("VoiceInteraction", ctx, new AbortSignal());


        throw new Error(`${propKey} service is not defined`);
      },
    }
  ) as {
    ArchetypeInteraction: IArchetypeInteraction;
    ChannelInteraction: IChannelInteraction;
    EventBus: IEventBus;
    ServerInteraction: IServerInteraction;
    UserInteraction: IUserInteraction;
    VoiceInteraction: IVoiceInteraction;

  };
}
